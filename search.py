#!/usr/bin/env python3
# Author: Lisandro Ubiedo, @_lubiedo
# Organization: Stratosphere Research Laboratory
# Maintainer: Veronica Valeros, @verovaleros

import os
import re
import gzip
import json
import argparse
import requests

data_url = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{YEAR}.json.gz"
data_file = "nvdcve-1.1-{YEAR}.json.gz"
data_path = f"{os.getcwd()}/data/"
args = None
short = None
count = -1

CVEs = list()


class bcolors:
    """
    https://stackoverflow.com/questions/287871/how-to-print-colored-text-in-python#287944
    """
    c = {
        'BLUE': '\033[94m',
        'LOW': '\033[92m',
        'MEDIUM': '\033[93m',
        'HIGH': '\033[91m',
        'CRITICAL': '\033[95m',
        'ENDC': '\033[0m',
        'BOLD': '\033[1m',
        'UNDERLINE': '\033[4m'
    }

    def h(s):
        return f"{bcolors.c['BOLD']}{s}:{bcolors.c['ENDC']}"

    def cseverity(s):
        if s in bcolors.c:
            return bcolors.c[s]
        bcolors.c['BOLD']


def shorten():
    i = len(CVEs)
    for entry in CVEs:
        print(f'''
{bcolors.h('ID')} {
    bcolors.c['UNDERLINE']}{entry['cve']['CVE_data_meta']['ID']}{
        bcolors.c['ENDC']}
{bcolors.h('DATE')} {entry['publishedDate']}
{bcolors.h('IMPACT')}''')
        if 'baseMetricV3' in entry['impact']:
            severity = \
                    entry['impact']['baseMetricV3']['cvssV3']['baseSeverity']
            print(f'''    Base Score: {bcolors.cseverity(severity)}{
        entry['impact']['baseMetricV3']['cvssV3']['baseScore']}{
            bcolors.c['ENDC']}
    Severity: {bcolors.cseverity(severity)}{severity}{bcolors.c['ENDC']}
    Vector: {entry['impact']['baseMetricV3']['cvssV3']['vectorString']}''')
        else:
            print('''    Undefined.''')
        print(f'''
{bcolors.h('DESC')} {entry['cve']['description']['description_data'][0]['value']}''')
        i -= 1
        if i > 0:
            print("---")


def search(data_json, search_query):
    """
    This function parses the NIST JSON data,
    identifies each CVE, and searches for the
    given query on each of the CVE description.
    """
    # The user can specify the maximum results to retrieve
    # This is stored in the global variable: count
    max_results_counter = 0

    # Create the regex to search for the query on the data
    regex = re.compile(f'({search_query})', re.I)

    for entry in data_json['CVE_Items']:
        # Filter for CVE entries
        if 'cve' in entry:
            # Obtain CVE description
            cve_description = entry['cve']['description']
            # Process each description data?
            for d in cve_description['description_data']:
                # Find the first match of search query regex
                # in the CVE description data retrieved
                if regex.search(d['value']) is not None:
                    CVEs.append(entry)
                    max_results_counter += 1
                    break
        # If the maximum results are reached, exit
        if max_results_counter == count:
            break

    if short:
        shorten()
    return


def download_nist_data(fetch_url):
    """
    Donwload NIST CVE data for a given year
    """
    try:

        # Download NIST data for a given year
        content = requests.get(fetch_url, headers={"Accept-Encoding": "gzip"})

        # If download was not successful raise exception
        if content.status_code != 200:
            raise Exception("Error requesting compressed NIST JSON.")

        # If download was successful, load it as JSON
        try:
            data = json.loads(gzip.decompress(content.content))
        except json.decoder.JSONDecodeError:
            raise Exception("Error decoding NIST JSON")

        return data

    except Exception as err:
        print(f"Exception in download_nist_data: {err}")
        return False

def main():
    global args, short, count

    # Parse arguments
    parser = argparse.ArgumentParser(description="Search CVEs on NIST data")
    parser.add_argument('-s', '--short', default=False,
                        help="Print short version of each CVE entry",
                        action='store_true')
    parser.add_argument('-y', '--year', required=True, type=str,
                        help="Year to look for. Examples: '2020' (single) \
                        or '2019,2020' (list) or '2010-2020' (range)")
    parser.add_argument('-c', '--count', type=int,
                        help="Number of results to display")
    parser.add_argument('search', type=str, help="Search query, regex capable")
    args = parser.parse_args()

    short = args.short
    count = args.count
    search_years = None

    # The number of years could be provided in three formats:
    # 1 - Single year: 2011
    # 2 - Sequence of years: 2011,2012,2013
    # 3 - Range of years: 2010-2014
    try:
        # Parse range of years, e.g.: 2010-2014
        if args.year.index('-') == 4:
            (year_min, year_max) = args.year.split('-')
            search_years = range(int(year_min), int(year_max))
        else:
            parser.print_help()
            quit(1)
    except:
        # Parse sequence of years, e.g.: 2011,2012,2013
        search_years = args.year.split(',')

    # Search for CVE for every year
    for year in search_years:
        # Download NIST data for a given year
        try:
            content = requests.get(data_url.replace('{YEAR}', str(year)),
                                   headers={"Accept-Encoding": "gzip"})
        except:
            print(f"Error downloading NIST data. Check your internet connection.")
            break

        # If download was not successful raise exception
        if content.status_code != 200:
            raise Exception("Error requesting compressed NIST JSON.")

        # If download was successful, load it as JSON
        try:
            data = json.loads(gzip.decompress(content.content))
        except json.decoder.JSONDecodeError:
            raise Exception("Error decoding NIST JSON")

        # Search for the given search query in the
        # downloaded data
        search(data, args.search)

    if len(CVEs) > 0 and not short:
        print(json.dumps(CVEs))


if __name__ == '__main__':
    main()
